![image-20221011182601445](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221011182601445.png)

取反后加一可以放1的位置，是右侧第一个0，也就是之前的1的位置。如果右侧都是0  取反都是1 那么相加之后第一个1 就是他第一个0 的位置，也就是第一个1 的位置。

堆可以很容易用数组存储，因为可以知道父   左  右  的位置

优先级队列就是堆   只是名字叫做队列

C++的重载符号  等于  比较运算器

计数排序（高考分数）   基数排序（多次入桶，从低位开始入；高位晚排序，所以优先级高）

虽然堆排很像是冒泡但是由于是树的结构    稳定性并不高

实验来讲快排是最快的，堆排用的空间少，归并有稳定性（左边开始码）![image-20221014101540668](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221014101540668.png)

sort是基础类型会是快排，自定义类型会用归并yyiyin因为有稳定性

递归算法都可以改成非递归的，因为他不给我们压栈，我们自己压栈就可以了

申请两个栈，先头右左   然后入栈给第二个，它里面是头右左，出栈的时候是左右头，这就是后序遍历

每棵树都可以分解为右边界，然后我们先左再头

返回黑盒，一个树的遍历需要返回多个信息，可以直接构造一个![image-20221016115844495](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221016115844495.png)然后返回他   把所有信息都攥在手里，然后加工出自己的信息  可以解决所有树形DP

面试的题目都是带有区分度的，带有技巧的。一般都是能优化的

后续节点  中序遍历的下一个    前驱结点   中序遍历的上一个

贪心策略是为了筛人的，不是为了区分度，因为：这个人贪心策略没想出来，这个东西筛人不太好

[哈希算法与MD5、SHA - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/37165658)

哈西表只有那么大，是为了防止内存爆掉，我们很怕出现很多不同的数，所以利用哈希均分的特点压缩词频，不怕碰撞，把他们扔到同一个表中

链太长了，认为其他链也长，找起来就麻烦了，所以就扩容了

扩容代价是O(N) 因为每一个元素都要重新计算hash,并排序

离线扩容：C   C++ 这种现场生成的语言无法做到，而有JVM的语言可以做到，用户体验就是，没有扩容，增删改查是log n

布隆过滤器：只会将白名单不小心当成黑名单，而不会不小心将黑名单当做白名单（也就是拉黑永远有效，但是有误杀）

位图：用其他的数组拼接成位数组

布隆过滤器：一个长度为m的位数组，来一个数，通过哈希运算，用很多不同的哈西函数计算出位置，描黑；之后来找的时候，重新运算，如果全黑，认为在里面，有白的，不在里面；单样本大小和布隆过滤器设计完全没关系

设计hashkey的时候要选择不会重复的，并且比较多的，国家作为key就不太好；key的种类要很多，高频  中频  低频 分类的时候

用模的方式分组   数据迁移的时候，代价很高

一致性哈希没有模，用圈表示 数据迁移很简单；但是机器少的时候，做不到一上来就均分；加了新节点，马上不均分；   一个机器有很多节点，让这些节点去抢环就好了，这样还能管理负载（性能强的节点多）

[(34条消息) 为什么JDK中String类的indexof不使用KMP或者Boyer-Moore等时间复杂度低的算法编辑器_SamXCode的博客-CSDN博客_string.indexof() 时间复杂度](https://blog.csdn.net/samxie0816/article/details/46703821)

小于2N   复杂度是线性的![image-20221021144325102](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221021144325102.png)

单调栈可以找到左边第一个比他大的数据和在弹出 的时候（这时候才开始处理他）找到右边第一个比他大的shuju

包装一个类，里面是来与不来的最大值，员工的快乐值。底层员工封装好返回上面他遍历自己的底层员工laimax = next.bulai想加，否则就是  bulaimax = Math.max(next.lai,next,bylai).就是求每一个节点需要什么数据，怎么来的。

线索二叉树，morrir遍历，修改底层节点指针之后再改回来

递归一定能回调自己三次：![image-20221023091155132](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221023091155132.png)

![image-20221023092023831](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221023092023831.png)

如果必须做第三次的二叉树的汇总信息的强整合，必须用二叉树的套路，否则可以用morris

在四十多亿个数字当中找到一个没有出现的数字：512分桶装法：分成512份，每个桶中统计数字数量，然后在这个范围再分为512份：：利用词频统计一定不够的特性来定位

无后效性的都可以用空间换时间使用动态规划，面试中一般都可以。记忆化搜索；严格依赖表结构的动态规划要纠结表结构

有序表的实现 AVL(高度)SB（size）树红黑树（颜色），跳表时间复杂度都差不多，区别就是实现的是否优雅。SB的改写难度最低；只是标签不同，到每个节点查的东西不一样

左旋右旋：头节点倒向哪边就是什么旋

红黑树做到了路径长度的倍数的规定

跳表从高层往底层找的方式   往底层填充的方式（从底层找没有任何意义）；跳表的思想更先进，效率只与数量分布有关和数据顺序无关（输入顺序），是一种解耦和（与用户的输入规律）

打表法：不想数学原理，根据规律直接写出答案，不关心数学过程

https://vip.aqdx29.com/videos/tag/virgin)



设计模式不需要炉火纯青，现在有分布式了，不需要那么大的架构了，又大又笨

构建单调性：可以把n   变成  logn  比如end数组，找最长递增子序列的；舍弃可能性就意味着是一种

子数组问题，想以这个位置结束有什么解；舍弃可能性是一个大思路，；可以用假设结果法；平凡解剪枝法

很多二围图像问题都是转化为一维图像解的
