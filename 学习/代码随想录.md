代码随想录



#### 链表

头结点如何

[TOC]

移除呢，其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点

![image-20220428094955926](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220428094955926.png)

可不可以 以一种统一的逻辑来移除 链表的节点呢。

其实**可以设置一个虚拟头结点**，这样原链表的所有节点就都可以按照统一的方式进行移除了。



对于环形链表：**fast相对于slow是一次移动一个节点，所以不可能跳过去**。

#### 哈希表

一般哈希碰撞有两种解决方法， 拉链法和线性探测法。

拉链法发生冲突的元素都被存储在链表中。使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题

哈西底层使用红黑树实现：

红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。std::map 和std::multimap 的key也是有序的

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。

简单总结一下：
哈希表总共有三种类型
1.数组，相信大家对数组已经相当熟悉了，不再赘述
2.set
对于set类型又分出来三种
对于std::set和std::multiset来说底层实现都是红黑树，红黑树是用平衡搜索二叉树实现的，是要求有序的，所以对于这两种类型来说数据是有序的。对于unordered_set来说，底层实现是哈希表，哈希表的本质是数组是不要求有序的所以数据元素无序，哈希表的优点就是时间效率高，装填和删除操作都是常数时间
3.map类型参考set即可，总结一句话只要记住底层实现是红黑树的就有序，另外multiset和multimap数据还可以重复（从名字也可以看出来）但是操作效率低.底层实现是哈希表的数据无序但是操作效率高

**使用数组来做哈希的题目，是因为题目都限制了数值的大小。**

如果想要第一个数组是最短的（对他处理更简单）

```java
if (nums1.length > nums2.length) {
            return intersect(nums2, nums1);
        }
```



#### 字符串

**当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。**

**很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

KMP：

**PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度**。

![image-20220501141546897](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220501141546897.png)

就是后缀等于前  

两数之和 就不能使用双指针法，因为[1.两数之和 (opens new window)](https://programmercarl.com/0001.两数之和.html)要求返回的是索引下标， 而双指针法一定要排序，一旦排序之后原数组的索引就被改变了。

假设在之前有一个漏掉的，但是结果计算，他和最长前后缀相驳

栈：

栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。

**栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。**

栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。

**括号匹配是使用栈解决的经典问题**

学到了删除字符串中的所有相邻重复项 5

#### 二叉树

什么是完全二叉树？

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

**二叉树可以链式存储，也可以顺序存储。**那么链式存储方式就用指针， 顺序存储的方式就是用数组。

遍历：

- 深度优先遍历
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先遍历
  - 层次遍历（迭代法）

![image-20220506081351649](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220506081351649.png)

前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。

而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

**递归算法！**：

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。



前序和中序是完全两种代码风格，并不像递归写法那样代码稍做调整，就可以实现前后中序。

统一写法

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if (root != null) st.push(root);
        while (!st.empty()) {
            TreeNode node = st.peek();
            if (node != null) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）
                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）
                st.push(node);                          // 添加中节点
                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。
                
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.peek();    // 重新取出栈中元素
                st.pop();
                result.add(node.val); // 加入到结果集
            }
        }
        return result;
    }
}
```

```text
if (cur->left == NULL && cur->right == NULL) {
    终止处理逻辑
}
```

```c++
if (cur->left == NULL && cur->right == NULL) {
    终止处理逻辑
}
```

为什么没有判断cur是否为空呢，因为上面的逻辑可以控制空节点不入循环。

**如果需要遍历整棵树，递归函数就不能有返回值。如果需要遍历某一条固定路线，递归函数就一定要有返回值！**

**前序和后序不能唯一确定一棵二叉树！**，因为没有中序遍历无法确定左右部分，也就是无法分割。

**在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**。

1. 求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从低向上的遍历方式。

#### 回溯

回溯是递归的副产品，只要有递归就会有回溯。

**虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法**。

**组合是不强调元素顺序的，排列是强调元素顺序**。

回溯算法中函数返回值一般为void。

再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。

所以回溯函数终止条件伪代码如下：

```text
if (终止条件) {
    存放结果;
    return;
}
```

回溯函数遍历过程伪代码如下：

```c++
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```

**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**

**树层去重的话，需要对数组排序！**

学到了全排列

为什么不是广度优先遍历：

在深度优先遍历的时候，**不同状态之间的切换很容易** 

  使用 Deque 是 Java 官方 Stack 类的建议

  Deque<Integer> path = new ArrayDeque<>(len);

```java
 for (int num : nums) {

    output.add(num);

 }

Collections.swap(output,sidx, i);
```



# 底部

