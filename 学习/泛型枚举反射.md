# 内部类

内部类定义在哪  他的作用范围就是哪!![image-20220826172207088](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826172207088.png)



成员内部类：成员内部类，不允许static  允许 static final![image-20220826175855767](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826175855767.png)

静态内部类![image-20220826180047535](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826180047535.png)

局部内部类

```java
public void hello(){
  class IdCard{
    String aaa;
  }
}
```

![image-20220826181251499](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826181251499.png)



匿名内部类就是局部内部类的一个简要写法

![image-20220826182544238](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826182544238.png)



![image-20220826084838249](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826084838249.png)

编译的时候通过反射来读取注解

@Override注解表示不覆盖就报错，加上这个注解就一定要重写父类的方法

元注解是解释其他注解的注解

```java
定义一个注解
@Target(value = {    ,     ,})
@Retention(value = )
@Documented
@Inherited
@interface MyAnnotation{String name default=""；}//定义了参数，使用注解的时候要声明   如果只有一个，使用value命名，可以省略，自动为0
```

![image-20220826090344733](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826090344733.png)

![image-20220826091317420](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826091317420.png)

![image-20220826091614072](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826091614072.png)

![image-20220826091704376](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826091704376.png)

![image-20220826093758401](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826093758401.png)

![image-20220826094202812](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826094202812.png)

![image-20220826095321369](D:\MarkDown\typora\typora文件\学习\image-20220826095321369.png)

![image-20220826100302887](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826100302887.png)

根加载器打印不出来， ClassLoader parent = ClassLoader.getSystemClassLoader.getparent().getParent();  打印的是null

```java
Class clazz = A.class;
clazz.getname();    clazz.getSimpleName();
Field[] field = clazz.getFields();//只能找到public属性
Field[] fields = clazz.getDeclaredFields();//能找到所有属性
Field name = clazz.getField("name");//获得指定属性
Field name = clazz.getDeclaredField("name");
//////////////////////////////////////////////////////
Method[] methods = clazz.getMethods();
Method[] methods = clazz.getDeclaredMethods();
Method method = clazz.getMethod("setName",String.class);//因为有重载所以需要输入参数
/////////////////////////////////////////////////////
Constructor[] constructor = clazz.getContructors();
Constructor[] constructor = clazz.getDeclaredContructors();
Constructor constructor = clazz.getDeclaredContructor(String.class,int.class);
User user = (User) clazz.newInstance();//调用的是无参构造器
Constructor constructor = clazz.getDeclaredConstructor(String.class,int.class);
User user2 = (User) constructor.newInstance("abc",12);
////////////////////////////////////////////////////通过反射操纵方法，通过反射操纵属性
Method setname = clazz.getDecaredMethod("setName",String.class);
setname.invoke("user2","cby");//传递对象和方法所需要的参数
Field name = clazz.getDecaredField("name");
name.setAccessible(true);//设置取消安全检测，否则不能直接操作私有属性
name.set("aaaa");
///////////////////////////////////////////////////
Annotation annotation = (Annotation)clazz.getAnnotation(myannotation.class);
String value = annotation.value();
```

![image-20220826114332067](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826114332067.png)

泛型，加载进内存应该会有class的



## 类加载

![image-20220826123452306](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826123452306.png)

加载：

验证;

准备：默认初始化，并分配空间

解析：常量池内的 	符号引用--->直接引用 ---我找陈博云   我找6.048的人

只有初始化是程序员指定的，其余的是JVM虚拟机指定的

初始化：是类加载，不是new创建对象

![image-20220826123517594](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826123517594.png)

![image-20220826124329431](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826124329431.png)

![image-20220826125220932](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826125220932.png)

![image-20220826134705799](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826134705799.png)

和实例还没有关系，因为正处于类加载

初始化的时候是按顺序收集的：所有静态变量的赋值动作和静态代码快中的赋值语句操作

class B{  static int num =100}   B.num并没有构建对象   

直接使用类的静态属性也会导致类的加载

![image-20220826140043987](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826140043987.png)

# 泛型

编译的时候就进行检查，我们使用的时候无需类型转换

泛型可以理解为形参

泛型的本质是类型参数化

![image-20220826142955238](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826142955238.png)

泛型类

```java
public class Generic <T>{
  private T key;//T是外部使用类的时候来指定的
}
```

![image-20220826143417242](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826143417242.png)

![image-20220826144004865](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826144004865.png)

![image-20220826144052031](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826144052031.png)

因为我们会将泛型在编译时转化为Object,基本数据类型并不是继承object

![image-20220826144309271](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826144309271.png)

![image-20220826144904925](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826144904925.png)

![image-20220826145209890](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826145209890.png)

子类泛型扩展也要保证至少一个和父类一致

![image-20220826151731111](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826151731111.png)

泛型方法是独立于泛型类的,名字相同也是独立的；泛型方法和泛型类里面的普通方法并不一样

```java
class B<T>{public <E> E get(ArrayList<E> list){return list.get(random.nextInt(list.size()));}//泛型方法   支持静态
          public T add(T t){...}//泛型里面的普通方法    不支持静态
          }
```

![image-20220826153137981](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826153137981.png)

泛型里面的多态不存在，

```java
public static void show(Box<Number> box){Number firist = box.getfirist;}    Box<Integer> box2 = new Box<>();
show(box2);//不可以
```

![image-20220826155939371](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826155939371.png)

？代表任意类型![image-20220826160007906](D:\MarkDown\typora\typora文件\分析与摘抄\image-20220826160007906.png)

extend  上限![image-20220826160054576](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826160054576.png)

只能传number或number的子类

![image-20220826161031627](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826161031627.png)

传进来的的上限元素不能填充元素，因为你不确定里面装的是什么

![image-20220826183455837](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826183455837.png)

不保证填充的约束![image-20220826183756750](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826183756750.png)

compared使用的是super  因为父类先初始化，之后比较的话父类进行比较是很合理的。

![image-20220826185413768](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826185413768.png)

![image-20220826191629436](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826191629436.png)

![image-20220826191641790](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826191641790.png)

![image-20220826192420879](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826192420879.png)

![image-20220826194003579](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826194003579.png)

![image-20220826194204401](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826194204401.png)

