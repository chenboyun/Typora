## 资源

### 网络资源

#### 概述

[(22条消息) 计算机网络----校招笔试面试常考内容总结__missTu_的博客-CSDN博客_计算机校招笔试](https://blog.csdn.net/u013075024/article/details/93101757)

[计算机网络之面试常考 - 赵亚飞 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html)

## 考点

### 常考考点

DNS解析具体过程 ARP协议 IP地址/MAC地址 HTTP1.0/1.1/2.0/3.0改进 TCP拥塞控制 窗口问题

## 书籍学习

### 计算机网络课本复习

#### 第一章概述



#### 第二章物理层

#### 第三章数据链路层

三个基本问题：封装成帧、透明传输、差错检验

MTU Maximum Transfer Unit   最大传输单元：数据部分长度上限    ESC  字节填充     BER Bit Error Rate 误码率     CRC  Cyclic Redundancy Check  循环冗余检测（无比特差错的传输，但不是可靠传输）

帧丢失、帧重复、帧失序

PPP:点对点协议  用户计算机和ISP进行通信时所使用的数据链路层协议：简单-：接收-CRC-处理；封装成帧；透明性；接受多种网络层协议；检验链接状态；MTU是数据部分最大长度，不是帧的总长度；；只支持全双工链路

字节填充：转义、控制字符   变成两个字节的序列

LCP  link Control Protocol  链路控制协议    建立、配置、测试数据链路链接的协议

NCP  network control protocol 网络控制协议  （一套，可以支持不同的网络层协议）

零比特填充:5--1 

PPP 的工作状态：建立LCP链接；NCP根据网络层协议的不同选用不同的网络层协议--；数据通路进入链路打开状态；开始发送分组；结束后链路终止；链路静止

##### 广播信道的数据链路层

动态媒体接入控制：随机接入、受控接入；

链路层分为两层：逻辑链路控制LLC  媒体介入控制MAC。。。。之后LLC用的特别少，很多只有MAC了，这个是用于广播信道的，和PPP不同；

**适配器**：包含物理层和数据链路层的功能；不使用CPU；计算机的硬件地址就在适配器的ROM中；网卡

CSMA/CD   载波监听多点接入、碰撞检测  carrier sense multiple Access with collision detection；此时适配器在网络中收发信号；这个不能同时接收和发送，所以不能是全双工，只能是半双工；争用期2t(碰撞窗口)512bit所需时间；采用截断二进制指数退避（推迟）来确定重传信息；r^2-10中取一个乘2t;;动态退避-重传需推迟的时间随次数增大；为了防止太短了，还没发现碰撞就发完了，所以规定了最短帧长64字节；；强化碰撞-发送干扰信号告诉所有用户发生了碰撞；帧间最小时间间隔96bit；空闲后等96bit;

**集线器**：双绞线链接各个站点；工作在物理层，只发送0 1 不检测碰撞

集线器和转发器都是工作在物理层，但集线器拥有多个接口，其功能与转发器并无太大区别。这种关系也是网桥和交换机之间的关系，交换机其实也只是有多个接口而已，它的功能与网桥并无二致。

信道利用率  a = t/T0

MAC  硬件地址 物理地址 MAC地址  48位  多个适配器就有多个MAC 地址 这个地址是固化了的，前三个字节是IEEE给固定的，后三个自由分配；IEEE的第一个字节的倒数第一位I/G管理单个站地址或组地址（进行多播）；倒数第二位G/L全球管理或本地管理；

地址格式:662 n 4    2:类型，上一层使用的是什么协议7当类型大于0x0600的时候表示长度，小于0x0600时才表示类型

以太网传输数据以帧为单位，

集线器：变成了一个碰撞域，要使用相同的以太网技术，否则会失败；集线器就是多接口转发器；这是物理层的拓展；

交换机：数据链路层拓展以太网；相当于多接口网桥；工作在全双工模式，每个接口都与一个单台主机相连；可并行工作；速率是累加的，不同于集线器；使用自学习算法：记录、广播、过滤（交换表内记录）；只有发的时候带地址；设置过期时间；生成树协议解决兜圈子问题；

交换机不同于总线以太网，但是还叫做以太网，因为他还使用帧格式

虚拟局域网；只向虚拟局域网中的主机发送广播，避免了广播风暴；VLAN的MAC格式是6642 多了VLAN标记，前两个总是设计为0x8100

网速快了，比如说到了吉比特以太网的时候，如果使用半双工，为了使a保持较小，使用了分组突发和载波延伸的功能。；10吉比特只有全双工；

PPPoE以太网帧的格式没有用户名和密码，所以把ppp封装到以太网中传输；

#### 第四章网络层

##### 网际协议IP：

ARP  Adress Resolution Protocol  地址解析协议

ICMP  Integer Control Message Protocol  网际控制报文协议

IGMP  Integer Group Management Protocol

直接交付：在自己的路由表中   间接交付

网络号：主机号    网络号表示主机或路由器所连接到的网络；

A   B  C都是单播地址； 1   10   110  1110    1111   属于类别位；   D类地址是多播；

网络号：全 0 本网络；  全  1只在本网络下进行传播（A的01111111表示本地软件环回测试）     主机号 全  0 网络地址（192.168.162.0表示一个网络地址） 全 1本网络的所有主机；B类地址 的128.0.0.0不可指派，只能指派128.1.0.0

无名网络：路由器不分配IP地址；

IP地址是网络层和以上使用的地址，是一种逻辑地址（由软件实现的）

在不同网络上传输数据时MAC的源地址和目的地址要发生变化

ARP高速缓存IP地址到硬件地址的映射表；广播请求分组（我的物理地址是...我的IP是；我想找IP是....的那个他），响应分组是普通单播（我的IP是... 物理地址是...）；每一个映射地址项目都设置生存时间；

物理地址的格式千变万化，很是复杂，IP编指把这个复杂的问题解决了

超过MTU就会进行分片处理； 

生存时间TTL 之前单位是秒，现在单位是 跳数；

协议  占8位：ICMP 1 IGMP 2 IP 4 TCP 6 UDP 17

路由表：最重要的两个信息：目的网络地址，下一跳地址；

特定主机路由：对特定的一个主机指定一个路由；

默认路由：

##### 划分子网、构造超网

<网络号><子网号><主机号>

使用了子网掩码，使路由器可以方便的从目的IP中提取所要的子网的网络地址。（相与，得到子网的网络地址）

所有网络都必须使用子网掩码；子网号不能为全0或全1，

使用分组时的分组转发：路由表必须包含{目的地址，子网掩码，下一跳地址}{检查直接相连的-是否直接交付；特定主机路由；路由表中的每一行；默认路由；都没有就报错 }

构造超网：无分类编址：CIDR   将IP分为网络前缀和主机号   <网络前缀><主机号>   如127.0.32.0/20

分配到CIDR地址快后仍旧可以划分子网

路由聚合：构成超网;-路由表中的一个项目可以表示原来传统地址的很多个（用cidr来查找地址块）

查找路由的时候可能会有不止一个结果--选择具有最长网络前缀的路由（最长匹配、最佳匹配）

##### ICMP 网际控制报文协议 Internet control message protocol

ICMP作为IP报文的数据部分进行传输

ICMP分为 ICMP 差错报告报文（终点不可达、时间超过、参数问题、重定向 ）  ICMP询问报文（回送请求、回答报文  ）测试目的网站是否可达；时间戳请求和回答  ping直接使用网络层的ICMP而没有通过运输层的TCP和UDP

##### 互联网路由选择协议

静态路由选择策略（非自适应路由选择），动态路由选择策略（自适应路由选择）

分层次路由选择协议  AS自治系统{IGP  EGP}内部网关协议IGP最多是RIP OSPF 外部网关协议EGP常用BGP{域间路由选择   域内路由选择}

内部网关协议RIP:路由信息协议；routing information protocol 一种分布式的，基于距离向量的  简单的协议（只适用于小型互联网）记录到每个网络的跳数；按规定时间间隔向相邻的路由器交换全部信息；他计算最短跳数的算法是 距离向量算法（表中存放：目的地址，下一跳路由器，距离）使用用户数据报UDP(端口520)进行传输一个RIP报文最多放25个路有信息；好消息传播快，坏消息传播慢（我以为你能到，但是原来是你给我的报错我没收到）这个协议开销小、规模小

内部网关协议OSPF 开放最短路径优先：open shortest path firth；使用了分布式链路状态协议；向所有路由器发送信息：（洪泛法）本路由都和那些路由相连以及相应代价；链路状态发生变化时才用洪泛法发送信息；之后每个路由器都能生成全网一样的链路状态数据库；为了OFPS能用于规模很大的网络，将AS分为更小的’区域‘；使用层次结构的区域划分；使用IP数据报传送数据；可以负载均衡，而RIP只能选择一条跳数少的；

##### IP多播

多播组的标识符，与加入该组的IP相关联（其实就是D类地址）使用D类地址作为目的地址，使用IGMP协议

##### VPN  NAT

​	专用地址：仅内部通信10.0.0.0  10.255.255.255     172.16.0.0   172.31.255.255   192.168.00  192.168.255.255  1A 16B 256C这些网络也叫做专用互联网、本地互联网

网络地址转换 NAT network address translation

在外界通信时将本地IP转化为全球IP,NAT路由器必须至少有一个全球IP(路由器上需要安装NAT软件)这个是借用，他有几个全球IP就有几个主机可以同时接入，轮流使用，他有一个NAT地址转换表，记录出入时的心就地址转换;使用了端口号，那么就可以通过TPC来知道对应的主机了（旧IP端口号只和本机有关系，新端口号确定自己对应的是哪个本地主机，）

##### MPLS 

#### 第五章运输层

##### 运输层概述

通信的实体是主机的进程的(是主机实现特定功能，因为进程是动态的)；分用和复用；数据传输一般只到网络层，因为知道IP就能传输了 

面向连接的TCP （传输控制协议 Transmission Control Protocol）提供可靠的面向连接的运输服务，不提供广播或多播（HTTP FTP）；  无连接的UDP（用户数据报协议 User Datagram Protocol）(DNS TFTP RIP IGMP)

传输的数据叫做TCP报文段  UDP用户数据报；

熟知端口号、系统端口号（0-1023）（DNS 53 FTP 21 HTTP 80），登记端口号（1024-49151），客户端端口号、短暂端口号，进程运行时动态选择的

##### UDP 

比IP多了复用分用和差错检测;;无连接的，尽最大努力交付的 ，面向报文的（给多大，发多大）没有拥塞控制（以恒定速度发送数据，允许部分丢失，可能会造成严重瘫痪）；首部开销小；

首部格式:2222 源端口  目的端口 长度  检验和  还有一个伪首部，在前面12位的；不向下向上传送，仅用来计算校验和；

接收方发现目的端口号不正确、不存在，就丢弃该报文，并发送ICMP差错报文端口不可达给发送方

TCP 

面向连接的；点对点的；可靠交付的；全双工的；设有发送缓存和接收缓存；面向字节流的，发送接收的数据快大小可能不对应，因为是将数据看成无结构的子节流的。TCP根据网络拥塞程度和窗口值确定一个报文段应该多长，可切可等；UDP的长度由应用进程给出；TCP链接的端点叫做套接字或插口：（端口号拼接IP地址即为套接字）

停止等待协议：（运输层并不使用这种协议）发送后收到发送确认后在发送，没收到确认就超时重传（要保留副本，为分组和确认分组设置编号）    确认丢失 确认迟到

自动重传请求  ARQ automatic Repeat reQuest   没收到确认，就再次发送；

显然，这个自动重传利用率太低了，所以出现了   连续ARQ协议和滑动窗口协议

滑动窗口：累计确认：对按序到达的最后一个分组发送确认

##### TCP报文的首部格式

源端口  目的端口 序号（seq）（本报文段发送数据的第一个字节的序号）  确认号（希望下一个收到的报文段序号，比如有了500   就在确认报文段中写501）  数据偏移（4位的长度，记录首部长度，15*4 =60字节就是首部最大长度）**ACK**  (确认ACK  当ACK=1 时，确认号字段才有效  TCP中，连接建立后所有报文段都必须把ACK置1 )  PSH (推送PSH  不等待缓存，立刻发送)   RST(复位   TCP连接中出现差错，，释放连接，然后重新建立连接)  **SYN**（同步SYN  连接建立时用来同步序号；SYN =1 ACK = 0表示这是一个连接请求报文段；如果对方同意，发送11 ，可以看出，**SYN=1表示这是一个连接请求或连接接受报文**）FIN(终止FIN  用来释放一个连接)  窗口（发送方告知对方自己的接受窗口的窗口值，就是说，还有多少缓存）

TCP可靠传输的实现：

以字节为单位的滑动窗口；窗口可能不动（没有收到新的确认而且窗口值不变，收到新的确认，但是窗口值变小了）描述一个窗口需要三个指针P1P2P3   P3-P1发送窗口   P2-P1  已经发送但是还没有收到确认的字节数；   P3-P2   允许发送但是目前未发送的部分；对于接受窗口，没有按序到达的需要继续缓存在接收窗口内 ；发送窗口只是发送缓存的一部分，他们的后沿是重合的；接收方必须有累积确认的功能，也可以在自己有数据发送的时候把确认号捎带上；

RTT 报文段往返时间：要得到一个超时重传时间：

选择确认：SACK:要在TCP首部选项加入允许SACK的选项（首部长度限制最多指明四个字节快的信息）（这个东西不经常使用）

##### TCP流量控制：  

rwnd 接收窗口 receiver window  单位是字节

让发送方发送的不要过快，让接收方来得及接收

当接收方窗口从0变成可接收的时候为了防止发送方接收不到窗口值大于0的报文，发送方会发送 零窗口探测报文段（携带一个字节，如这样就能让接收方发送窗口值了）

提高传输效率：  推迟发送确认报文；糊涂窗口综合症（接收窗口够大才发送一个大的报文）

##### TCP拥塞控制

网络中对某一资源的需求大于他能提供的，就会发生拥塞

拥塞控制就是防止过多数据注入网络中，是一个全局性的过程；而流量控制是点对点的

拥塞由多种情况组成：（如果单纯的增大一个节点的缓存，那么可能很多报文都会在这个缓存里，然后外界就会发送很多重传；提高处理器性能也差不多，就是瓶颈的转移）拥塞常常趋于恶化；重传并不会缓解拥塞，会加剧网络拥塞；很多情况下甚至正是拥塞控制本身成为引起网络性能恶化甚至死锁的原因；‘

开环控制（不可中途修改）    闭环控制（）

慢开始（由小到大逐渐增大拥塞窗口的数值（1-2个最大报文）没收到一个新的报文段的确认后，将拥塞窗口最多增加一个SMSS[最大报文段]（传四个，做多多四个）可以看出，每个传输轮次都加倍（实际上没收到一个确认，窗口大小就增加））  拥塞避免  快重传   快恢复

慢开始门限  ssthresh  

拥塞避免  加法增大  按线性规律缓慢增长   惩罚减小（出现快重传 门限为win/2   窗口几乎减半）

出现超时，  门限变为窗口的一半，拥塞窗口复位为1

快重传：让发送方尽早知道发生了个别报文段的丢失：立刻发送确认，收到了失序的报文段也要立刻发送已收到报文段的重复确认---一连收到三个重复确认，知道确实没收到，此时立刻进行重传，免得被认为是拥塞了（有可能只是走的慢，但是，不等他了）此时，只是丢失了个别的报文段，执行快恢复算法：

门限为窗口值的一半，窗口值减半，此时开始拥塞避免；（由于收到了三次快重传的确认，可以把拥塞窗口适当的扩大，比如加上三个分组）  

发送窗口的值不能超过接收方的窗口值

主动队列管理   AQM

队列已满的时候，后来的分组全部丢失，   尾部丢弃策略  出现丢失，由于可能有很多TCP复用IP，所以多个连接同时进入慢开始；

全局同步：     主动丢弃分组  最小门限  最大门限  随机丢弃分组；

##### TCP的运输链接管理

连接建立   数据传送 链接释放

传输控制模块TCB   SYN==1 不能携带数据，但是要占用一个序号   ACK可以携带数据  如果不携带数据，序号不变

；之前的请求建立连接可能突然出现；但是A没有建立请求，所以不理睬他的确认，此时B不能自己建立连接，B不收到A的确认，知道A没有建立连接；



链接释放：

FIN 不携带数据也占用一个序号；时间等待计时器  两个最长报文段寿命   超时重传

保活计时器：防止客户机出了故障然后不知道这件事；

#### 第六章应用层

HTTP

##### 域名系统  DNS   Domain Name System

DNS  能把主机名字转化为IP   层状树结构命名方法，分布式的域名系统（大多数名字本地解析）   域名服务器专门解析域名，运行域名服务器程序   DNS请求报文使用UDP发送   回答报文把IP地址传回，应用获得目的主机IP就可以正常通信了；如果本地DNS不能回答，他就成为另一个客户,向其他域名服务器请求；级别低的卸载左边，级别高的写在右边；<63;<255

顶级域名：国家顶级域名   通用顶级域名  基础结构域名（反向域名  arpa）

DNS的管辖范围不是域而是区  区是域的子集

主机查询--递归查询：找不到就以DNS客户的方式，向上发送请求报文，

​				迭代查询

##### 文件传送协议

FTP File Transfer Protocol  基于TCP     TFTP基于UDP：联机访问  透明存取 远地文件； 20-21

##### cookie与session

`Cookie` 最开始被设计出来是为了弥补 HTTP 在状态管理上的不足，它是服务器发送到用户浏览器并保存在本地的小型文本数据，会在浏览器下次向服务器发起请求时，被携带并发送到服务器上。Cookie 按存储类型可分为两类：Session Cookie（会话 Cookie）和 Permanent Cookie（持久化 Cookie）。

- Session Cookie：会话 Cookie 是存放在客户端浏览器的内存中，只在当前会话有效，在用户关闭会话页或浏览器时就销毁；
- Permanent Cookie：持久化 Cookie 是存放在客户端硬盘中，超过过期时间或用户直接在网页中单击“注销”等按钮才会失效。



`Session` 翻译过来就是会话，`会话`是指客户端与服务端进行通讯的过程，比如用户在浏览器中点击一个超链接访问 Web 资源，到关闭该标签页就是一个会话过程。   sessionID可以是一个cookie          Session 对象，用来保存相关数据，比如用户角色、登录时间等；

|  Cookie  |                           Session                            |                                                              |
| :------: | :----------------------------------------------------------: | ------------------------------------------------------------ |
| 存储方式 |   Cookie 存储在客户端，方便与 JS 交互，方便获取用户信息。    | Session 存储在服务端，高效、安全，不依赖浏览器环境。         |
| 存储类型 |                   Cookie 只能存储字符串。                    | Session 可以存储任意数据类型。                               |
| 存储大小 | Cookie 大小有限制（4KB），同一域名下的数量也有限制（20 个）  | Session 没有类似的限制。                                     |
| 生命周期 | Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能。  | Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。 |
|  安全性  | Cookie 是本地存储，不是很安全，别人可以分析存放在本地的 Cookie 并进行欺骗，存在 [CSRF](http://dedenotes.com/html/cross-site.html) 风险。 |                                                              |
|   特点   | Cookie 是客户端存储用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。 | Session 是在服务端存储的一个数据结构，用来跟踪用户的状态，这个数据可以保存在内存、文件、数据库中。 |
|   总结   | 1. Cookie 遵循同源策略，不能跨域访问，除非特别部署。 2. SessionID 是客户端的唯一标识，存储在 Cookie 中，它是维持一个会话的核心。 3. Cookie 和 Session 都是为了在无状态的 HTTP 协议之上维护会话状态，使得服务端可以知道当前是和哪个客户在“打交道”。 |                                                              |





### 计算机网络自顶向下

#### 笔记；来自网络

[(22条消息) 计算机网络（自顶向下方法）学习笔记_头秃的程序员小王的博客-CSDN博客_自顶向下方法](https://blog.csdn.net/qq_39326472/article/details/88089747)

#### 缩写单词：

DSL  数字用户线

DSLAM   用户接入复用器

LAN  局域网

WiFi  无线局域网接入

#### 第一章









# 马士兵底层原理

程序层和内核层

natstat -natp

port监听，如果是请求自己的端口，就建立连接，

四元组：两个套接字  四元组里能够发生变化的只有端口号

突然间断开，双方并不知道，但是有一个心跳

TCP/IP 协议是传输层的一个面向连接的安全可靠的一个传输协议，三次握手的机制是为了保证能建立一个安全可靠的连接，那么第一次握手是由客户端发起，客户端会向服务端发送一个报文，在报文里面：SYN标志位置为1，表示发起新的连接。当服务端收到这个报文之后就知道客户端要和我建立一个新的连接，于是服务端就向客户端发送一个确认消息包，在这个消息包里面：ack标志位置为1，表示确认客户端发起的第一次连接请求。以上两次握手之后，对于客户端而言：已经明确了我既能给服务端成功发消息，也能成功收到服务端的响应。但是对于服务端而言：两次握手是不够的，因为到目前为止，服务端只知道一件事，客户端发给我的消息我能收到，但是我响应给客户端的消息，客户端能不能收到我是不知道的。所以，还需要进行第三次握手，第三次握手就是当客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个ack标志位置1的确认消息。通过以上三次连接，不管是客户端还是服务端，都知道我既能给对方发送消息，也能收到对方的响应。那么，这个连接就被安全的建了。
四次挥手
四次握手机制也是由客户端去发起，客户端会发送一个报文，在报文里面FIN位标志位置一，当服务端收到这个报文之后，我就知道了客户端想要和我断开连接，但是此时服务端不一定能做好准备，因为当客户端发起断开连接的这个消息的时候，对于服务端而言，他和还有可能有未发送完的消息，他还要继续发送，所以呢，此时对于服务端而言，我只能进行一个消息确认，就是我先告诉服务端，我知道你要给我断开连接了，但是我这里边还可能没有做好准备，你需要等我一下，等会儿我会告诉你，于是呢，发完这个消息确认包之后，可能稍过片刻它就会继续发送一个断开连接的一个报文啊，也是一个FIN位置1的报文也是由服务端发给客户端的啊，这个报文表示服务端已经做好了断开连接的准备，那么当这个报文发给客户端的时候，客户端同样要给服务端继续发送一个消息确认的报文一共有四次，那么，通过这四次的相互沟通和连接，我就知道了，不管是服务端还是客户端都已经做好了断开连接的!

#### IPV6

**![image-20220823104303585](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823104303585.png)**



缩头不缩尾；ipv6

#### http

![img](https://www.runoob.com/wp-content/uploads/2018/09/dffdff.png)

![image-20220823111103791](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823111103791.png)

默认访问80端口，自动补全

cookie放在首部，http默认是持久连接

GET:检索、获取    POST：创建、更新

URL有长度限制，是浏览器限制的，不同浏览器长度限制不同

![image-20220823113712874](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823113712874.png)

缓存过期，询问服务器是否过期，如果服务器说过期，就请求一个新的

CDN 内容分发网络;content delivery network  可以预缓存

任播：

##### DNS

网络设置里面就可以看到DNS服务器地址   www.bilibili.com  要一级一级的问，比如先问.com ![image-20220823121432617](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823121432617.png)



输入URL  回车后发生什么？

1.通过DNS解析URL中域名对应的服务器主机IP地址																																	 2.与服务器主机三次握手建立TCP连接
3.发送HTTP请求 获取服务器返回的数据
4.浏览器解析HTML、CSS和JS等前端文件，渲染页面

#### HTTPS

Http S   S是保护的意思HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

443   HTTPS 专用端口

SSL是TLS的前身，现在都是支持TLS而不支持SSL

443端口只是建立连接 的时候协商怎么建立连接，传输数据还是得http

HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。

HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：

- 1、TCP 三次同步握手

- 2、客户端验证服务器数字证书

- 3、DH 算法协商对称加密算法的密钥、hash 算法的密钥

- 4、SSL 安全加密隧道协商完成

- 5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。

  http  https 的区别：：

  

- HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。

- 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。

- HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

![image-20220823094447725](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823094447725.png)

**1、客户端发起 HTTPS 请求**

这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。

**2、服务端的配置**

采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。

这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。

**3、传送证书**

这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。

**4、客户端解析证书**

这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。

如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。

**5、传送加密信息**

这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

**6、服务端解密信息**

服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。

**7、传输加密后的信息**

这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。

**8、客户端解密信息**

客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。

![image-20220823100511907](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823100511907.png)

用两个密钥来进行加密，而私钥是只有自己才有的；一般私钥就放在服务器里，数据经过公钥加密只能被私钥解密，经过私钥加密只能被公钥解密；

TLS对称和非对称加密都有用到；

SSL证书就是保存在源服务器的数据文件，由CA颁发，如果一个网站有这个证书，访问的时候就会自动将80端口改为443端口；建立三次握手之后会告诉**服务端**我有TLS的支持和加密套件，然后发送一个随机数给服务端；之后服务端会回复支持的版本和选择的加密套件。并且服务器也生成一个随机数给客户端。之后服务器会出式自己的证书。然后给客户端自己的公钥。如果服务器也要客户端的证书（网银什么的）就会发送一个请求。之后客户端生成第三个随机数，用刚刚的公钥进行加密，并发送给服务器（预主密钥）

![image-20220823101910420](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823101910420.png)

非对称加密消耗非常大，得到会话密钥之后就进行对称加密吧