[TOC]

#### 注释

在 **/\*** 和 ***/** 注释内部，**//** 字符没有特殊的含义。在 **//** 注释内，**/\*** 和 ***/** 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释

#### 数据类型

从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。

换名字：typedef int feet;

枚举：创建枚举，需要使用关键字 **enum**。

```
enum color { red, green, blue } c;
c = blue;
```

当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 **extern** 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。

extern int a,b;

```c++
#include <iostream>
using namespace std;
 
// 变量声明
extern int a, b;
extern int c;
extern float f;
  
int main ()
{
  // 变量定义
  int a, b;
  int c;
  float f;
 
  // 实际初始化
  a = 10;
  b = 20;
  c = a + b;
 
  cout << c << endl ;
 
  f = 70.0/3.0;
  cout << f << endl ;
 
  return 0
```

#####  左值右值

- **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。

- **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

  10  =  20

  #### 变量的作用域

  - 在函数参数的定义中声明的变量，称为形式参数。

程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。

#### 常量

整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

222uL

字符常量：

\r  回车

\v 垂直制表符

\b   退格键

\f 换页符

字符串常量：

您可以使用 **\** 做分隔符，把一个很长的字符串常量进行分行。

string greeting2 = "hello, **\
**            runoob

定义常量：、

1. \#define LENGTH 10    #define WIDTH  5
2.    const int  LENGTH = 10;   const int  WIDTH  = 5;//写在里面

定义成 const 后的常量，程序对其中只能读不能修改。



看到了 C++ 修饰符类型

#### 修饰符的类型

改变基本类型含义

- signed
- unsigned
- long
- short

#### 存储类

**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在//他是变量{有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。}

**extern** 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。

**mutable** 说明符仅适用于类的对象；mutable 成员可以通过 const 成员函数修改。

**thread_local** 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义

#### C++运算符

sizeof	sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。**sizeof** 是一个关键字，它是一个编译时运算符，用于判断变量或数据类型的字节大小。

**（点）运算符和 ->（箭头）运算符**用于引用类、结构和共用体的成员。点运算符应用于实际的对象。箭头运算符与一个指向对象的指针一起使用。访问结构的成员时使用点运算符，而通过指针访问结构的成员时，则使用箭头运算符。

**指针**：C++ 提供了两种指针运算符，一种是取地址运算符 &，一种是间接寻址运算符 *。；；取地址运算符 & & 是一元运算符，返回操作数的内存地址。；；\* 是一元运算符，返回操作数**所指定地址的变量**的值。

声明时变量前加 "基本类型 *" -------该指针变量表示另一个普通变量的**地址**  :int * 或 char *；；声明时变量前加 "基本类型 * *"-------该二级指针变量表示另一个一级"基本类型 *"指针变量 **地址**  

#### 循环

**break:**嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。

**goto :** goto语句允许把控制无条件转移到同一函数内的被标记的语句。

```c++
goto label;
..
.
label: while(){};
```

#### 判断

```c++
switch(a) {
      case 100:
         cout << "这是外部 switch 的一部分" << endl;
         switch(b) {
            case 200:
               cout << "这是内部 switch 的一部分" << endl;
         }
   }
```

#### 函数

函数 **strcat()** 用来连接两个字符串，函数 **memcpy()** 用来复制内存到另一个位置。

向函数传递参数的**指针调用**方法，把参数的地址复制给形式参数。void swap(int *x, int *y)

向函数传递参数的**引用调用**方法，把引用的地址复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。按引用传递值，参数引用被传递给函数，就像传递其他值给函数一样。因此相应地，在下面的函数 **swap()** 中，您需要声明函数参数为引用类型，该函数用于交换参数所指向的两个整数变量的值。void swap(int &x, int &y)

当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。int sum(int a, int b=20)

Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递

与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：

```C++
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```

#### 数字

##### 随机数

```
 srand( (unsigned)time( NULL ) );
 
   /* 生成 10 个随机数 */
   for( i = 0; i < 10; i++ )
   {
      // 生成实际的随机数
      j= rand();
      cout <<"随机数： " << j << endl;
   }
```

#### 数组

```c++
type arrayName [ arraySize ];
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
int a[3][4] = {  
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};
```

数组指针：

使用数组名作为常量指针是合法的；*(runoobAarray + 4) 是一种访问 runoobAarray[4] 数据的合法方式。

传递数组给函数：

C++ 传数组给一个函数，数组类型自动转换为指针类型，因而传的实际是地址。

每种方式都会告诉编译器将要接收一个整型指针{

```
void myFunction(int *param)
void myFunction(int param[10])
void myFunction(int param[])//param 是一个指向数组的指针
```

}

从函数返回数组：

您必须声明一个返回指针的函数，如下：

int * myFunction()

#### 字符串

```c++
char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\0'};
char site[] = "RUNOOB";
	strcpy(s1, s2);
复制字符串 s2 到字符串 s1。
strlen(s1);
返回字符串 s1 的长度。
strcmp(s1, s2);
如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。
  strchr(s1, ch);
返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。
  strstr(s1, s2);
返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。
```

C++新增的string

```
len = str3.size();
 1. append("/C++") -- 在字符串的末尾添加字符
 2. find(/C++) -- 在字符串中查找字符串
 4. insert() -- 插入字符
 5. length() -- 返回字符串的长度
 6. replace(pos,2,"") -- 替换字符串
 7. substr() -- 返回某个子字符串

```

#### 指针

```c++
每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，
 cout << "var1 变量的地址： ";
   cout << &var1 << endl;
```

**指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址

```
type *var-name;
//在这个语句中，星号是用来指定一个变量是指针。
不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。
int  var = 20;   // 实际变量的声明
   int  *ip;        // 指针变量的声明
   ip = &var;       // 在指针变量中存储 var 的地址
   所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。
```

空指针的地址是0

在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。（根据指针类型指向下个）

指针指向数组的时候，不可以加 **&**:

把指针运算符 * 应用到 var 上是完全可以的，但修改 var 的值是非法的。这是因为 var 是一个指向数组开头的常量，（数组就是一个指针）

```
*(var + 2) = 500;//合法的，因为var没有改变，他是个常量
```

指针数组：

```
int *ptr[MAX];
```

显然*是取值的意思，那么ptr是一个地址，这个地址存的是一个整数（或字符）  ；他取值才是一个类型，显然他是一个地址

指针的指针：

一个指向 int 类型指针的指针：

```c++
int **var;
```

传递指针给函数，只需要简单地声明函数参数为指针类型即可。

```
void getSeconds(unsigned long *par);
unsigned long sec;
   getSeconds( &sec );
```

```
double getAverage(int *arr, int size)
avg = getAverage( balance, 5 ) 
arr是一个指向数组都指针。  传递忽略类型和*,调用的时候传过去啥，函数接收到的变量就是啥
```

从函数返回指针：

```
int * myFunction(){return r;}  ... r=int *r;
```

#### 引用

引用很容易与指针混淆，它们之间有三个主要的不同：

- 不存在空引用。引用必须连接到一块合法的内存。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。

```
int&  r = i;
double& s = d;
```

在这些声明中，& 读作**引用**。

// 函数声明 void swap(int& x, int& y);

**C++ 函数传参：**

(1)将变量名作为实参和形参。这时传给形参的是变量的值，传递是单向的。如果在执行函数期间形参的值发生变化，并不传回给实参。因为在调用函数时，形参和实参不是同一个存储单元。// 同 c

(2) 传递变量的指针。形参是指针变量，实参是一个变量的地址，调用函数时，形参(指针变量)指向实参变量单元。这种通过形参指针可以改变实参的值。// 同 c

(3) C++提供了 传递变量的引用。形参是引用变量，和实参是一个变量，调用函数时，形参(引用变量)指向实参变量单元。这种通过形参引用可以改变实参的值。

- 选择成员的时候，引用使用点 **.** 来查找，而指针则使用 **->** 来查找。
-  指针可能传递一个 NULL 过来，因此在使用前必须检查有效性；引用则必然代表某个对象，不需要做此检查。

引用作为返回值：

当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。

（1）以引用返回函数值，定义函数时需要在函数名前加 **&**

（2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。

double& setValues(int i) {  }

**int& r = i;** 和 **int r = i;** 不同之处应该是内存的分配吧，后者会再开辟一个内存空间

引用与被引用的地址是一样的

#### 日期和时间

为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。